using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Gress;
using YoutubeDownloader.Core.Downloading.Tagging;
using YoutubeDownloader.Core.Utils;
using YoutubeExplode;
using YoutubeExplode.Converter;
using YoutubeExplode.Videos;

namespace YoutubeDownloader.Core.Downloading;

public class YoutubeVideoDownloader
{
    private readonly YoutubeClient _youtube = new(Http.Client);
    private readonly MediaTagInjector _tagInjector = new();

    public async Task<IReadOnlyList<VideoDownloadOption>> GetVideoDownloadOptionsAsync(
        VideoId videoId,
        CancellationToken cancellationToken = default)
    {
        var manifest = await _youtube.Videos.Streams.GetManifestAsync(videoId, cancellationToken);
        return VideoDownloadOption.ResolveAll(manifest);
    }

    public async Task<IReadOnlyList<SubtitleDownloadOption>> GetSubtitleDownloadOptionsAsync(
        VideoId videoId,
        CancellationToken cancellationToken = default)
    {
        var manifest = await _youtube.Videos.ClosedCaptions.GetManifestAsync(videoId, cancellationToken);
        return SubtitleDownloadOption.ResolveAll(manifest);
    }

    private async Task DownloadVideoAsync(
        string filePath,
        VideoDownloadOption videoOption,
        IProgress<Percentage>? progress = null,
        CancellationToken cancellationToken = default)
    {
        await _youtube.Videos.DownloadAsync(
            videoOption.StreamInfos,
            new ConversionRequestBuilder(filePath)
                .SetContainer(videoOption.Container)
                .SetPreset(ConversionPreset.Medium)
                .Build(),
            progress?.ToDoubleBased(),
            cancellationToken
        );
    }

    private async Task DownloadSubtitlesAsync(
        string baseFilePath,
        IReadOnlyList<SubtitleDownloadOption> subtitleOptions,
        IProgress<Percentage>? progress = null,
        CancellationToken cancellationToken = default)
    {
        var progressMuxer = progress?.CreateMuxer();
        var progresses = progressMuxer is not null
            ? subtitleOptions.Select(_ => progressMuxer.CreateInput()).ToArray()
            : null;

        for (var i = 0; i < subtitleOptions.Count; i++)
        {
            var subtitleOption = subtitleOptions[i];

            var code = subtitleOption.TrackInfo.IsAutoGenerated
                ? $"{subtitleOption.TrackInfo.Language.Code}-auto"
                : $"{subtitleOption.TrackInfo.Language.Code}";

            var filePath = Path.ChangeExtension(baseFilePath, $"{code}.srt");

            await _youtube.Videos.ClosedCaptions.DownloadAsync(
                subtitleOption.TrackInfo,
                filePath,
                progresses?[i].ToDoubleBased(),
                cancellationToken
            );
        }
    }

    public async Task DownloadAsync(
        VideoDownloadRequest request,
        IProgress<Percentage>? progress = null,
        CancellationToken cancellationToken = default)
    {
        var progressMuxer = progress?.CreateMuxer();
        var videoDownloadProgress = progressMuxer?.CreateInput(90); // 90%
        var subtitleDownloadProgress = progressMuxer?.CreateInput(10); // 10%

        var dirPath = Path.GetDirectoryName(request.FilePath);
        if (!string.IsNullOrWhiteSpace(dirPath))
            Directory.CreateDirectory(dirPath);

        await DownloadVideoAsync(
            request.FilePath,
            request.VideoOption,
            videoDownloadProgress,
            cancellationToken
        );

        await DownloadSubtitlesAsync(
            request.FilePath,
            request.SubtitleOptions,
            subtitleDownloadProgress,
            cancellationToken
        );

        try
        {
            await _tagInjector.InjectTagsAsync(request.FilePath, request.Video, cancellationToken);
        }
        catch
        {
            // Not critical, ignore
        }
    }
}